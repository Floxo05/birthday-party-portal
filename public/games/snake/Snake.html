<!doctype html>
<html lang="de">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
    <title>Snake – Birthday Portal</title>
    <style>
        :root {
            --bg: #0b0f17;
            --fg: #e6ecf2;
            --muted: #94a3b8;
            --apple: #ef4444;
            --snake: #22c55e;
            --board: #0f172a;
            --grid: #172036;
            --accent: #2563eb;
        }

        html, body {
            margin: 0;
            height: 100%;
            background: var(--bg);
            color: var(--fg);
            font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif
        }

        /* Scroll nur während des Spielens sperren */
        body.playing {
            overflow: hidden;
        }

        body.playing #game {
            touch-action: none;
        }

        .shell {
            display: grid;
            grid-template-rows:auto 1fr auto;
            min-height: 100%
        }

        header, footer {
            padding: 12px 16px;
            background: rgba(255, 255, 255, .03);
            border-bottom: 1px solid rgba(255, 255, 255, .06)
        }

        footer {
            border-top: 1px solid rgba(255, 255, 255, .06);
            border-bottom: 0
        }

        h1 {
            margin: 0;
            font-size: clamp(18px, 3.5vw, 24px)
        }

        .row {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap
        }

        .grow {
            flex: 1
        }

        main {
            display: grid;
            place-items: center;
            padding: 12px
        }

        .card {
            width: min(920px, 100%);
            background: rgba(255, 255, 255, .04);
            border: 1px solid rgba(255, 255, 255, .08);
            border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, .25);
            padding: 12px;
        }

        .hud {
            display: flex;
            gap: 12px;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px
        }

        /* Responsive square board */
        .boardWrap {
            display: grid;
            place-items: center
        }

        #game {
            width: min(92vw, 720px);
            max-height: 70vh;
            aspect-ratio: 1/1;
            height: auto;
            display: block;
            background: var(--board);
            border-radius: 12px
        }

        .badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 999px;
            background: rgba(255, 255, 255, .08);
            border: 1px solid rgba(255, 255, 255, .12);
            font-size: 12px
        }

        .pill {
            padding: 2px 10px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, .12)
        }

        .overlay {
            position: relative
        }

        .layer {
            position: absolute;
            inset: 0;
            display: grid;
            place-items: center;
            background: rgba(0, 0, 0, .45);
            backdrop-filter: blur(2px);
        }

        .layer.hidden {
            display: none
        }

        .panel {
            background: rgba(255, 255, 255, .06);
            border: 1px solid rgba(255, 255, 255, .12);
            border-radius: 16px;
            padding: 18px 20px;
            text-align: center;
            max-width: min(92vw, 820px)
        }

        button {
            appearance: none;
            border: none;
            border-radius: 12px;
            padding: 10px 14px;
            font-weight: 700;
            cursor: pointer;
            background: var(--accent);
            color: #fff
        }

        button.secondary {
            background: transparent;
            color: var(--fg);
            border: 1px solid rgba(255, 255, 255, .18)
        }

        .kv {
            display: grid;
            grid-template-columns:1fr auto;
            gap: 8px 12px;
            text-align: left;
            margin-top: 8px
        }

        .kv > div {
            padding: 4px 0;
            border-bottom: 1px dashed rgba(255, 255, 255, .12)
        }

        .kv > div:nth-child(odd) {
            color: var(--muted)
        }

        .err {
            margin-top: 8px;
            padding: 10px 12px;
            border-radius: 12px;
            border: 1px solid rgba(255, 0, 0, .35);
            background: rgba(255, 0, 0, .1)
        }
    </style>
</head>
<body>
<div class="shell" id="app">
    <header class="row">
        <h1>Snake</h1>
        <div class="grow"></div>
        <span id="ctx" class="badge">—</span>
    </header>
    <main>
        <section class="card overlay">
            <div class="hud">
                <div><strong>Score:</strong> <span id="score">0</span> &nbsp;•&nbsp; <strong>Highscore:</strong> <span
                        id="best">0</span></div>
                <div class="pill" id="diff">Geschwindigkeit: 1.0×</div>
            </div>
            <div class="boardWrap">
                <canvas id="game" aria-label="Snake Spielfeld"></canvas>
            </div>

            <!-- Start Layer -->
            <div id="startLayer" class="layer">
                <div class="panel">
                    <h2>Tippen oder Klicken zum Start</h2>
                    <p>Steuerung: WASD / Pfeiltasten / Wischgesten • Ziel: <strong>Friss rote Äpfel</strong>, ohne die
                        Wand oder dich selbst zu berühren.</p>
                    <button id="startBtn" type="button">Start</button>
                </div>
            </div>

            <!-- Game Over Layer -->
            <div id="gameOverLayer" class="layer hidden">
                <div class="panel">
                    <h2>Game Over</h2>
                    <div class="kv" id="summary"></div>
                    <div id="submitState" class="muted">Sende Ergebnis…</div>
                    <div class="err hidden" id="errBox"></div>
                    <p>
                        <button id="againBtn" type="button">Nochmal</button>
                        <button id="scoreboardBtn" class="secondary" hidden>Scoreboard</button>
                    </p>
                </div>
            </div>
        </section>
    </main>
    <footer class="row">
        <div class="muted">© Birthday‑Portal Mini‑Game</div>
        <div class="grow"></div>
        <div class="muted">WASD / Pfeile / Touch • Local Highscore • API Submit</div>
    </footer>
</div>

<script>
    // —— Kontext & Konfiguration ——
    const DEFAULTS = {
        callbackUrl: null,
        token: null,
        language: 'de',
        maxDurationMs: 5 * 60_000,
        requireVisibility: true,
        backoff: {attempts: 4, baseMs: 500}
    };
    window.GAME_CONFIG = window.GAME_CONFIG || {};

    function getCtx() {
        const u = new URL(location.href);
        const qp = Object.fromEntries(u.searchParams.entries());
        const match = u.pathname.match(/\/public\/game\/([^/?#]+)/);
        const gameIdFromPath = match ? decodeURIComponent(match[1]) : null;
        return {
            partyId: qp.partyId || null,
            playerId: qp.playerId || null,
            gameId: qp.gameId || gameIdFromPath || 'snake',
            sessionId: qp.sessionId || (crypto.randomUUID?.() ?? String(Date.now())),
            callbackUrl: qp.callbackUrl || window.GAME_CONFIG.callbackUrl || null,
            token: qp.token || window.GAME_CONFIG.token || null,
            lang: qp.lang || window.GAME_CONFIG.language || DEFAULTS.language
        };
    }

    const CTX = getCtx();
    const isFileOrigin = (location.origin === 'null' || location.protocol === 'file:');

    function normalizeCallbackUrl(url) {
        if (!url) return url;
        try {
            if (location.protocol === 'https:' && typeof url === 'string' && url.startsWith('http://')) {
                return 'https://' + url.slice('http://'.length);
            }
        } catch (_) {
        }
        return url;
    }
    const CFG = {
        callbackUrl: normalizeCallbackUrl(CTX.callbackUrl) || (isFileOrigin ? null : `${location.origin}/api/game-results`),
        token: CTX.token || null,
        language: CTX.lang,
        maxDurationMs: window.GAME_CONFIG.maxDurationMs ?? DEFAULTS.maxDurationMs,
        requireVisibility: window.GAME_CONFIG.requireVisibility ?? DEFAULTS.requireVisibility,
        backoff: window.GAME_CONFIG.backoff || DEFAULTS.backoff
    };

    document.getElementById('ctx').textContent = [`party:${CTX.partyId?.slice(0, 8) || '—'}`, `player:${CTX.playerId?.slice(0, 8) || '—'}`, `game:${CTX.gameId}`].join(' • ');

    // —— Canvas & Grid (responsive & crisp) ——
    const canvas = document.getElementById('game');
    const g = canvas.getContext('2d');
    let W = 0, H = 0, CELL = 24, COLS = 0, ROWS = 0;

    function sizeBoard() {
        const cssSize = Math.min(Math.max(280, window.innerWidth - 32), Math.max(320, window.innerHeight - 260));
        const S = Math.floor(cssSize);
        const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        canvas.style.width = S + 'px';
        canvas.style.height = S + 'px';
        canvas.width = Math.floor(S * dpr);
        canvas.height = Math.floor(S * dpr);
        W = canvas.width;
        H = canvas.height;
        // 24–32 Zellen pro Seite, abhängig von Größe
        CELL = Math.max(18 * dpr, Math.min(28 * dpr, Math.floor(Math.min(W, H) / 26)));
        COLS = Math.floor(W / CELL);
        ROWS = Math.floor(H / CELL);
    }

    // —— Game State ——
    const state = {
        startedAt: null,
        endedAt: null,
        over: false,
        paused: false,
        running: false,
        score: 0,
        best: Number(localStorage.getItem(`snake_highscore_${CTX.gameId}`) || 0),
        tickMs: 140,
        tAccum: 0,
        dir: {x: 1, y: 0},
        nextDir: {x: 1, y: 0},
        snake: [],
        apple: null,
        eatAnimMs: 0
    };
    document.getElementById('best').textContent = String(state.best);

    function reset() {
        state.over = false;
        state.paused = false;
        state.score = 0;
        state.tickMs = 140;
        state.tAccum = 0;
        state.dir = {x: 1, y: 0};
        state.nextDir = {x: 1, y: 0};
        sizeBoard();
        const startX = Math.floor(COLS / 3), startY = Math.floor(ROWS / 2);
        state.snake = [{x: startX - 2, y: startY}, {x: startX - 1, y: startY}, {x: startX, y: startY}];
        spawnApple();
        document.getElementById('score').textContent = '0';
        document.getElementById('diff').textContent = `Geschwindigkeit: ${(140 / state.tickMs).toFixed(1)}×`;
    }

    function spawnApple() {
        const occ = new Set(state.snake.map(s => `${s.x},${s.y}`));
        let x, y;
        do {
            x = Math.floor(Math.random() * COLS);
            y = Math.floor(Math.random() * ROWS);
        } while (occ.has(`${x},${y}`));
        state.apple = {x, y};
    }

    function difficulty() {
        const sF = Math.min(state.score / 10, 2.0);
        const tMin = state.startedAt ? Math.min((Date.now() - state.startedAt.getTime()) / 60000, 3) : 0;
        const f = 1 + sF * 0.5 + tMin * 0.3;
        state.tickMs = Math.max(60, 140 / f);
        document.getElementById('diff').textContent = `Geschwindigkeit: ${(140 / state.tickMs).toFixed(1)}×`;
    }

    function update() {
        // decay eat animation timer
        state.eatAnimMs = Math.max(0, state.eatAnimMs - state.tickMs);

        const nd = state.nextDir, d = state.dir;
        if (nd.x !== -d.x || nd.y !== -d.y) state.dir = {x: nd.x, y: nd.y};
        const head = state.snake[state.snake.length - 1];
        const nx = head.x + state.dir.x, ny = head.y + state.dir.y;
        if (nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS) return gameOver();
        for (let i = 0; i < state.snake.length - 1; i++) {
            const s = state.snake[i];
            if (s.x === nx && s.y === ny) return gameOver();
        }
        state.snake.push({x: nx, y: ny});
        if (state.apple && nx === state.apple.x && ny === state.apple.y) {
            state.score++;
            state.eatAnimMs = 220; // trigger mouth-open animation
            document.getElementById('score').textContent = String(state.score);
            spawnApple();
        } else {
            state.snake.shift();
        }
        difficulty();
    }

    function draw() {
        const styles = getComputedStyle(document.documentElement);
        // board bg
        g.fillStyle = styles.getPropertyValue('--board');
        g.fillRect(0, 0, W, H);
        // grid
        g.strokeStyle = styles.getPropertyValue('--grid');
        g.lineWidth = 1;
        g.beginPath();
        for (let x = 0; x <= COLS; x++) {
            g.moveTo(x * CELL, 0);
            g.lineTo(x * CELL, H);
        }
        for (let y = 0; y <= ROWS; y++) {
            g.moveTo(0, y * CELL);
            g.lineTo(W, y * CELL);
        }
        g.stroke();
        // apple
        if (state.apple) {
            const ax = state.apple.x * CELL + CELL / 2, ay = state.apple.y * CELL + CELL / 2,
                r = Math.max(6, CELL / 2 - 3);
            g.fillStyle = styles.getPropertyValue('--apple');
            g.beginPath();
            g.arc(ax, ay, r, 0, Math.PI * 2);
            g.fill();
            g.fillStyle = '#7c3f00';
            g.fillRect(ax - 2, ay - r - 6, 4, 8);
            g.fillStyle = '#16a34a';
            g.beginPath();
            g.moveTo(ax + 3, ay - r - 4);
            g.quadraticCurveTo(ax + 10, ay - r - 10, ax + 14, ay - r - 2);
            g.quadraticCurveTo(ax + 8, ay - r + 1, ax + 3, ay - r - 4);
            g.fill();
        }
        // snake body
        g.fillStyle = styles.getPropertyValue('--snake');
        const rr = (x, y, w, h, r) => {
            g.beginPath();
            g.moveTo(x + r, y);
            g.arcTo(x + w, y, x + w, y + h, r);
            g.arcTo(x + w, y + h, x, y + h, r);
            g.arcTo(x, y + h, x, y, r);
            g.arcTo(x, y, x + w, y, r);
            g.closePath();
            g.fill();
        };
        for (const s of state.snake) {
            rr(s.x * CELL + 1, s.y * CELL + 1, CELL - 2, CELL - 2, Math.min(6, CELL / 3));
        }

        // head details: eyes + animated mouth
        const head = state.snake[state.snake.length - 1];
        if (head) {
            const boardCol = styles.getPropertyValue('--board');
            const hx = head.x * CELL, hy = head.y * CELL;
            const cx = hx + CELL / 2, cy = hy + CELL / 2;
            // Outline
            g.strokeStyle = 'rgba(0,0,0,.35)';
            g.lineWidth = 2;
            g.strokeRect(hx + 1, hy + 1, CELL - 2, CELL - 2);
            // Eyes
            const eyeR = Math.max(2, Math.floor(CELL / 10));
            const dx = state.dir.x, dy = state.dir.y;
            let ex1, ey1, ex2, ey2;
            if (Math.abs(dx) > 0) {
                const offX = dx > 0 ? CELL * 0.25 : CELL * 0.75;
                ex1 = hx + offX;
                ey1 = hy + CELL * 0.35;
                ex2 = hx + offX;
                ey2 = hy + CELL * 0.65;
            } else {
                const offY = dy > 0 ? CELL * 0.25 : CELL * 0.75;
                ex1 = hx + CELL * 0.35;
                ey1 = hy + offY;
                ex2 = hx + CELL * 0.65;
                ey2 = hy + offY;
            }
            g.fillStyle = '#fff';
            g.beginPath();
            g.arc(ex1, ey1, eyeR, 0, Math.PI * 2);
            g.fill();
            g.beginPath();
            g.arc(ex2, ey2, eyeR, 0, Math.PI * 2);
            g.fill();
            g.fillStyle = '#000';
            g.beginPath();
            g.arc(ex1, ey1, eyeR * 0.5, 0, Math.PI * 2);
            g.fill();
            g.beginPath();
            g.arc(ex2, ey2, eyeR * 0.5, 0, Math.PI * 2);
            g.fill();
            // Mouth wedge in facing direction (opens on eat)
            const openT = Math.min(1, state.eatAnimMs / 220);
            if (openT > 0) {
                const ang = (dx !== 0 ? (dx > 0 ? 0 : Math.PI) : (dy > 0 ? Math.PI / 2 : -Math.PI / 2));
                const maxAngle = Math.PI * 0.6; // 108°
                const a1 = ang - maxAngle * openT * 0.5;
                const a2 = ang + maxAngle * openT * 0.5;
                const r = CELL * 0.7;
                const p1 = {x: cx + Math.cos(a1) * r, y: cy + Math.sin(a1) * r};
                const p2 = {x: cx + Math.cos(a2) * r, y: cy + Math.sin(a2) * r};
                g.fillStyle = boardCol;
                g.beginPath();
                g.moveTo(cx, cy);
                g.lineTo(p1.x, p1.y);
                g.lineTo(p2.x, p2.y);
                g.closePath();
                g.fill();
                if (openT > 0.5) {
                    g.strokeStyle = '#ef4444';
                    g.lineWidth = Math.max(2, CELL / 12);
                    g.beginPath();
                    g.moveTo(cx, cy);
                    g.lineTo(cx + Math.cos(ang) * CELL * 0.45, cy + Math.sin(ang) * CELL * 0.45);
                    g.stroke();
                }
            }
        }
    }

    let lastTs = 0, rafId;

    function loop(ts) {
        if (!lastTs) lastTs = ts;
        const dt = ts - lastTs;
        lastTs = ts;
        if (!state.over && !state.paused) {
            state.tAccum += dt;
            while (state.tAccum >= state.tickMs) {
                update();
                state.tAccum -= state.tickMs;
            }
            draw();
        }
        rafId = requestAnimationFrame(loop);
    }

    function start() {
        reset();
        state.startedAt = new Date();
        state.running = true;
        document.body.classList.add('playing');
        document.getElementById('startLayer').classList.add('hidden');
        document.getElementById('gameOverLayer').classList.add('hidden');
        cancelAnimationFrame(rafId);
        lastTs = 0;
        rafId = requestAnimationFrame(loop);
    }

    function gameOver() {
        if (state.over) return;
        state.over = true;
        state.running = false;
        document.body.classList.remove('playing');
        state.endedAt = new Date();
        if (state.score > state.best) {
            state.best = state.score;
            localStorage.setItem(`snake_highscore_${CTX.gameId}`, String(state.best));
        }
        document.getElementById('best').textContent = String(state.best);
        showSummaryAndSubmit();
    }

    function setDir(x, y) {
        state.nextDir = {x, y};
    }

    // Keyboard
    const keymap = {
        ArrowUp: [0, -1],
        KeyW: [0, -1],
        ArrowDown: [0, 1],
        KeyS: [0, 1],
        ArrowLeft: [-1, 0],
        KeyA: [-1, 0],
        ArrowRight: [1, 0],
        KeyD: [1, 0]
    };
    document.addEventListener('keydown', e => {
        const v = keymap[e.code];
        if (!v) return;
        e.preventDefault();
        if (!state.running) return;
        setDir(v[0], v[1]);
    });

    // Touch swipe (scroll nur im Spiel blockieren)
    let touchStart = null;
    canvas.addEventListener('touchstart', e => {
        if (!state.running) return;
        if (e.touches[0]) touchStart = {x: e.touches[0].clientX, y: e.touches[0].clientY};
        e.preventDefault();
    }, {passive: false});
    canvas.addEventListener('touchend', e => {
        if (!state.running) return;
        if (!touchStart) return;
        const t = e.changedTouches[0];
        const dx = t.clientX - touchStart.x, dy = t.clientY - touchStart.y;
        const adx = Math.abs(dx), ady = Math.abs(dy);
        if (Math.max(adx, ady) > 20) {
            if (adx > ady) setDir(dx > 0 ? 1 : -1, 0); else setDir(0, dy > 0 ? 1 : -1);
        }
        touchStart = null;
        e.preventDefault();
    }, {passive: false});

    // Start/Again buttons (robust on mobile)
    const startBtn = document.getElementById('startBtn');

    function safeStart(ev) {
        ev?.preventDefault?.();
        ev?.stopPropagation?.();
        start();
    }

    startBtn.addEventListener('click', safeStart);
    startBtn.addEventListener('pointerup', safeStart);
    startBtn.addEventListener('touchend', safeStart, {passive: false});
    document.getElementById('againBtn').addEventListener('click', safeStart);

    // Pause bei Tab-Verlust nur im Spiel
    document.addEventListener('visibilitychange', () => {
        if (document.hidden && CFG.requireVisibility) {
            state.paused = true;
        } else if (state.running) {
            state.paused = false;
        }
    });

    // —— Ergebnis-Submit (deaktiviert im file:// Modus) ——
    async function postResult(url, token, payload) {
        if (!url) {
            return {status: 'ok', local: true};
        }
        const res = await fetch(url, {
            method: 'POST',
            headers: {'Content-Type': 'application/json', ...(token ? {Authorization: `Bearer ${token}`} : {})},
            body: JSON.stringify(payload),
            keepalive: true
        });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        return res.json().catch(() => ({status: 'ok'}));
    }

    const sleep = ms => new Promise(r => setTimeout(r, ms));

    async function showSummaryAndSubmit() {
        cancelAnimationFrame(rafId);
        const layer = document.getElementById('gameOverLayer');
        const kv = document.getElementById('summary');
        kv.innerHTML = '';
        const payload = {
            partyId: CTX.partyId,
            playerId: CTX.playerId,
            gameId: CTX.gameId,
            sessionId: CTX.sessionId,
            score: state.score,
            maxScore: 9999,
            completed: true,
            durationMs: state.endedAt - state.startedAt,
            startedAt: state.startedAt.toISOString(),
            endedAt: state.endedAt.toISOString(),
            attempt: 1,
            metadata: {best: state.best, speed: (140 / state.tickMs)},
            clientInfo: {userAgent: navigator.userAgent, viewport: {w: innerWidth, h: innerHeight}}
        };
        for (const [k, v] of [['score', payload.score], ['highscore', state.best], ['dauerMs', payload.durationMs], ['startedAt', payload.startedAt], ['endedAt', payload.endedAt]]) {
            const a = document.createElement('div');
            a.textContent = k;
            const b = document.createElement('div');
            b.textContent = String(v);
            kv.append(a, b);
        }

        const submitState = document.getElementById('submitState');
        const errBox = document.getElementById('errBox');
        errBox.classList.add('hidden');
        errBox.textContent = '';
        layer.classList.remove('hidden');

        if (isFileOrigin && !CFG.callbackUrl) {
            submitState.textContent = 'Lokaler Testmodus – kein Submit';
            return;
        }

        let ok = false, lastErr = null;
        const {attempts, baseMs} = CFG.backoff;
        let i = 0;
        while (i < attempts) {
            try {
                submitState.textContent = i ? `Sende… Versuch ${i + 1}/${attempts}` : 'Sende Ergebnis…';
                const res = await postResult(CFG.callbackUrl, CFG.token, payload);
                submitState.textContent = 'Ergebnis gespeichert.';
                ok = true;
                if (res && res.scoreboardUrl) {
                    const btn = document.getElementById('scoreboardBtn');
                    btn.hidden = false;
                    btn.onclick = () => {
                        open(res.scoreboardUrl, '_blank');
                    };
                }
                break;
            } catch (e) {
                lastErr = e;
                i++;
                if (i < attempts) await sleep(baseMs * (2 ** i));
            }
        }
        if (!ok) {
            submitState.textContent = 'Speichern fehlgeschlagen.';
            errBox.textContent = lastErr?.message || 'Unbekannter Fehler';
            errBox.classList.remove('hidden');
        }
    }

    // Init
    (function init() {
        document.getElementById('startLayer').classList.remove('hidden');
        document.getElementById('gameOverLayer').classList.add('hidden');
        sizeBoard();
        draw();
    })();

    // Reflow on rotate/resize
    window.addEventListener('resize', () => {
        if (!state.running) {
            sizeBoard();
            draw();
        }
    });
</script>
</body>
</html>
