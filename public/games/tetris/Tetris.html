<!doctype html>
<html lang="de">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"/>
    <title>Tetris – Birthday Portal</title>
    <style>
        :root {
            --bg: #0b0f17;
            --fg: #e6ecf2;
            --muted: #94a3b8;
            --board: #0f172a;
            --grid: #1c2844;
            --accent: #2563eb;
            --ghost: #37415188;
            --cI: #06b6d4;
            --cJ: #3b82f6;
            --cL: #f59e0b;
            --cO: #fbbf24;
            --cS: #22c55e;
            --cT: #a855f7;
            --cZ: #ef4444
        }

        html, body {
            margin: 0;
            height: 100%;
            background: var(--bg);
            color: var(--fg);
            font: 16px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif
        }

        body.playing {
            overflow: hidden
        }

        .shell {
            display: grid;
            grid-template-rows:auto 1fr auto;
            min-height: 100%
        }

        header, footer {
            padding: 12px 16px;
            background: rgba(255, 255, 255, .03);
            border-bottom: 1px solid rgba(255, 255, 255, .06)
        }

        footer {
            border-top: 1px solid rgba(255, 255, 255, .06);
            border-bottom: 0
        }

        h1 {
            margin: 0;
            font-size: clamp(18px, 3.5vw, 24px)
        }

        .row {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap
        }

        .grow {
            flex: 1
        }

        main {
            display: grid;
            place-items: center;
            padding: 12px
        }

        .card {
            width: min(980px, 100%);
            background: rgba(255, 255, 255, .04);
            border: 1px solid rgba(255, 255, 255, .08);
            border-radius: 16px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, .25);
            padding: 12px;
        }

        .hud {
            display: flex;
            gap: 12px;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px
        }

        .stage {
            display: grid;
            grid-template-columns:1fr auto;
            gap: 12px
        }

        .boardWrap {
            display: grid;
            place-items: center
        }

        canvas#board {
            width: min(90vw, 640px);
            max-height: 78vh;
            aspect-ratio: 10/20;
            background: var(--board);
            border-radius: 12px;
            display: block
        }

        .sidebar {
            width: min(38vw, 260px);
            display: grid;
            gap: 12px;
            align-content: start
        }

        .box {
            background: rgba(255, 255, 255, .04);
            border: 1px solid rgba(255, 255, 255, .08);
            border-radius: 12px;
            padding: 10px
        }

        .nextGrid {
            display: grid;
            grid-template-columns:repeat(2, 1fr);
            gap: 8px
        }

        .badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 999px;
            background: rgba(255, 255, 255, .08);
            border: 1px solid rgba(255, 255, 255, .12);
            font-size: 12px
        }

        .overlay {
            position: relative
        }

        .layer {
            position: absolute;
            inset: 0;
            display: grid;
            place-items: center;
            background: rgba(0, 0, 0, .45);
            backdrop-filter: blur(2px);
            z-index: 10;
            pointer-events: auto
        }

        .panel {
            position: relative;
            z-index: 11;
            pointer-events: auto
        }

        .layer.hidden {
            display: none
        }

        .panel {
            background: rgba(255, 255, 255, .06);
            border: 1px solid rgba(255, 255, 255, .12);
            border-radius: 16px;
            padding: 18px 20px;
            text-align: center;
            max-width: min(92vw, 820px)
        }

        button {
            appearance: none;
            border: none;
            border-radius: 12px;
            padding: 10px 14px;
            font-weight: 700;
            cursor: pointer;
            background: var(--accent);
            color: #fff
        }

        button.secondary {
            background: transparent;
            color: var(--fg);
            border: 1px solid rgba(255, 255, 255, .18)
        }

        .err {
            margin-top: 8px;
            padding: 10px 12px;
            border-radius: 12px;
            border: 1px solid rgba(255, 0, 0, .35);
            background: rgba(255, 0, 0, .1)
        }

        @media (max-width: 800px) {
            .stage {
                grid-template-columns:1fr
            }

            .sidebar {
                grid-template-columns:repeat(2, 1fr)
            }
        }
    </style>
</head>
<body>
<div class="shell" id="app">
    <header class="row">
        <h1>Tetris</h1>
        <div class="grow"></div>
        <span id="ctx" class="badge">—</span>
    </header>
    <main>
        <section class="card overlay">
            <div class="hud">
                <div><strong>Score:</strong> <span id="score">0</span> • <strong>Lines:</strong> <span
                        id="lines">0</span> • <strong>Level:</strong> <span id="level">1</span> •
                    <strong>Highscore:</strong> <span id="best">0</span></div>
                <div class="badge" id="speed">Fallrate: —</div>
            </div>
            <div class="stage">
                <div class="boardWrap">
                    <canvas id="board" aria-label="Tetris Spielfeld"></canvas>
                </div>
                <aside class="sidebar">
                    <div class="box">
                        <div><strong>Nächster</strong></div>
                        <canvas id="next1" width="120" height="120"
                                style="background:rgba(255,255,255,.03);border-radius:10px"></canvas>
                    </div>
                    <div class="box">
                        <div><strong>Geparkt (Hold)</strong></div>
                        <canvas id="hold" width="120" height="120"
                                style="background:rgba(255,255,255,.03);border-radius:10px"></canvas>
                        <div class="badge" style="margin-top:6px">Taste: C / Shift</div>
                    </div>
                    <div class="box">
                        <div><strong>Steuerung</strong></div>
                        <small>
                            ←/→ bewegen • ↓ Soft Drop • ↑ / X drehen • Z drehen links • SPACE Hard Drop • C/Shift Hold •
                            P Pause • Touch: wischen/antippen
                        </small>
                    </div>
                </aside>
            </div>

            <div id="startLayer" class="layer">
                <div class="panel">
                    <h2>Tippen oder Klicken zum Start</h2>
                    <p>Steuerung: Pfeile/WASD, Z/X drehen, Space Hard Drop. Auf Touch: <em>wischen</em>
                        (links/rechts/unten), <em>tippen</em> zum Drehen, <em>lang tippen</em> = Hard Drop.</p>
                    <button id="startBtn" type="button">Start</button>
                </div>
            </div>
            <div id="gameOverLayer" class="layer hidden">
                <div class="panel">
                    <h2>Game Over</h2>
                    <div id="summary"></div>
                    <div id="submitState" class="muted">Sende Ergebnis…</div>
                    <div class="err hidden" id="errBox"></div>
                    <p>
                        <button id="againBtn" type="button">Nochmal</button>
                        <button id="scoreboardBtn" class="secondary" hidden>Scoreboard</button>
                    </p>
                </div>
            </div>
        </section>
    </main>
    <footer class="row">
        <div class="muted">© Birthday‑Portal Mini‑Game</div>
        <div class="grow"></div>
        <div class="muted">Keyboard/Touch • Local Highscore • API Submit</div>
    </footer>
</div>

<script>
    // ===== Context & Config =====
    const DEFAULTS = {
        callbackUrl: null,
        token: null,
        language: 'de',
        maxDurationMs: 5 * 60_000,
        requireVisibility: true,
        backoff: {attempts: 4, baseMs: 500}
    };
    window.GAME_CONFIG = window.GAME_CONFIG || {};

    function getCtx() {
        const u = new URL(location.href);
        const qp = Object.fromEntries(u.searchParams.entries());
        const m = u.pathname.match(/\/public\/game\/([^/?#]+)/);
        const gameIdFromPath = m ? decodeURIComponent(m[1]) : null;
        return {
            partyId: qp.partyId || null,
            playerId: qp.playerId || null,
            gameId: qp.gameId || gameIdFromPath || 'tetris',
            sessionId: qp.sessionId || (crypto.randomUUID?.() ?? String(Date.now())),
            callbackUrl: qp.callbackUrl || window.GAME_CONFIG.callbackUrl || null,
            token: qp.token || window.GAME_CONFIG.token || null,
            lang: qp.lang || window.GAME_CONFIG.language || DEFAULTS.language
        };
    }

    const CTX = getCtx();
    const isFileOrigin = (location.origin === 'null' || location.protocol === 'file:');

    function normalizeCallbackUrl(url) {
        if (!url) return url;
        try {
            if (location.protocol === 'https:' && typeof url === 'string' && url.startsWith('http://')) {
                return 'https://' + url.slice('http://'.length);
            }
        } catch (_) {
        }
        return url;
    }
    const CFG = {
        callbackUrl: normalizeCallbackUrl(CTX.callbackUrl) || (isFileOrigin ? null : `${location.origin}/api/game-results`),
        token: CTX.token || null,
        language: CTX.lang,
        maxDurationMs: window.GAME_CONFIG.maxDurationMs ?? DEFAULTS.maxDurationMs,
        requireVisibility: window.GAME_CONFIG.requireVisibility ?? DEFAULTS.requireVisibility,
        backoff: window.GAME_CONFIG.backoff || DEFAULTS.backoff
    };
    const LS_KEY = `tetris_highscore_${CTX.gameId}`;

    // ===== Board & Rendering =====
    const CAN = document.getElementById('board');
    const CTX2 = CAN.getContext('2d');
    let BW = 10, BH = 20; // logical columns/rows
    let CELL = 24, W = 0, H = 0, dpr = 1;

    function resizeBoard() {
        const cssW = Math.min(640, Math.floor(window.innerWidth * 0.9));
        const cssH = Math.min(800, Math.floor(window.innerHeight * 0.78));
        const css = Math.min(cssW, Math.floor(cssH * (BW / BH))); // maintain 10:20 aspect
        const cssHeight = Math.floor(css * (BH / BW));
        dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
        CAN.style.width = css + 'px';
        CAN.style.height = cssHeight + 'px';
        CAN.width = Math.floor(css * dpr);
        CAN.height = Math.floor(cssHeight * dpr);
        W = CAN.width;
        H = CAN.height;
        CELL = Math.floor(W / BW);
        CTX2.setTransform(1, 0, 0, 1, 0, 0); // reset any scaling
    }

    resizeBoard();
    window.addEventListener('resize', () => {
        const was = game.running && !game.paused;
        game.paused = true;
        resizeBoard();
        draw();
        game.paused = !was;
    });

    function colorOf(t) {
        const map = {I: '--cI', J: '--cJ', L: '--cL', O: '--cO', S: '--cS', T: '--cT', Z: '--cZ'};
        return map[t] || null;
    }

    function cssVar(name) {
        if (!name) return '';
        return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    }

    // ===== Game State =====
    const game = {
        running: false,
        paused: false,
        over: false,
        score: 0,
        lines: 0,
        level: 1,
        fallMs: 800,
        accum: 0,
        best: Number(localStorage.getItem(LS_KEY) || 0),
        startedAt: null,
        endedAt: null
    };
    (document.getElementById('best')).textContent = game.best;

    // 7-bag tetrominoes
    const SHAPES = {
        I: [[1, 1, 1, 1]],
        J: [[1, 0, 0], [1, 1, 1]],
        L: [[0, 0, 1], [1, 1, 1]],
        O: [[1, 1], [1, 1]],
        S: [[0, 1, 1], [1, 1, 0]],
        T: [[0, 1, 0], [1, 1, 1]],
        Z: [[1, 1, 0], [0, 1, 1]],
    };

    function rotate(mat) {
        const h = mat.length, w = mat[0].length;
        const out = Array.from({length: w}, () => Array(h).fill(0));
        for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) out[x][h - 1 - y] = mat[y][x];
        return out;
    }

    function clone(m) {
        return m.map(r => r.slice());
    }

    let bag = [];

    function nextType() {
        if (bag.length === 0) {
            bag = ['I', 'J', 'L', 'O', 'S', 'T', 'Z'];
            for (let i = bag.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [bag[i], bag[j]] = [bag[j], bag[i]];
            }
        }
        return bag.pop();
    }

    let grid = []; // BH rows of BW
    let cur = null, hold = null, holdUsed = false, nextT = nextType();

    function spawn() {
        const type = nextT;
        nextT = nextType();
        cur = {t: type, m: clone(SHAPES[type]), x: Math.floor(BW / 2) - 1, y: -2};
        holdUsed = false;
        if (collides(cur.m, cur.x, cur.y)) {
            gameOver();
            return;
        }
        renderMini(document.getElementById('next1'), nextT);
    }

    function collides(m, x, y) {
        const h = m.length, w = m[0].length;
        for (let yy = 0; yy < h; yy++) for (let xx = 0; xx < w; xx++) {
            if (!m[yy][xx]) continue;
            const gx = x + xx, gy = y + yy;
            if (gx < 0 || gx >= BW || gy >= BH) {
                if (gy < 0) continue;
                return true;
            }
            if (gy >= 0 && grid[gy][gx]) return true;
        }
        return false;
    }

    function place() {
        const m = cur.m, h = m.length, w = m[0].length;
        // Game Over, wenn etwas außerhalb landet würde
        for (let yy = 0; yy < h; yy++) for (let xx = 0; xx < w; xx++) {
            if (!m[yy][xx]) continue;
            const gx = cur.x + xx, gy = cur.y + yy;
            if (gx < 0 || gx >= BW || gy < 0 || gy >= BH) {
                gameOver();
                return;
            }
        }
        // Platzieren
        for (let yy = 0; yy < h; yy++) for (let xx = 0; xx < w; xx++) {
            if (m[yy][xx]) {
                const gx = cur.x + xx, gy = cur.y + yy;
                grid[gy][gx] = cur.t;
            }
        }
        // Linien prüfen
        let cleared = 0;
        for (let y = BH - 1; y >= 0; y--) {
            if (grid[y].every(v => v)) {
                grid.splice(y, 1);
                grid.unshift(Array(BW).fill(null));
                cleared++;
                y++;
            }
        }
        if (cleared) {
            game.lines += cleared;
            const points = [0, 100, 300, 500, 800][cleared] || cleared * 200;
            game.score += points * game.level;
            updateHUD();
            updateLevel();
        }
        spawn();
    }

    function updateLevel() {
        const lineLevel = 1 + Math.floor(game.lines / 10);
        const elapsed = game.startedAt ? (Date.now() - game.startedAt.getTime()) / 1000 : 0;
        const timeLevel = 1 + Math.floor(elapsed / 30); // +1 Level alle 30s
        game.level = Math.max(lineLevel, timeLevel);
        game.fallMs = Math.max(80, 800 - (game.level - 1) * 60);
        document.getElementById('speed').textContent = `Fallrate: ${game.fallMs}ms`;
        document.getElementById('level').textContent = game.level;
    }

    function hardDrop() {
        while (!collides(cur.m, cur.x, cur.y + 1)) cur.y++;
        place();
    }

    function softDrop() {
        if (!collides(cur.m, cur.x, cur.y + 1)) cur.y++; else place();
    }

    function move(dx) {
        if (!collides(cur.m, cur.x + dx, cur.y)) cur.x += dx;
    }

    function rotateCur() {
        const r = rotate(cur.m);
        if (!collides(r, cur.x, cur.y)) cur.m = r;
        else if (!collides(r, cur.x - 1, cur.y)) {
            cur.x -= 1;
            cur.m = r;
        } else if (!collides(r, cur.x + 1, cur.y)) {
            cur.x += 1;
            cur.m = r;
        }
    }

    function holdSwap() {
        if (holdUsed) return;
        const old = hold;
        hold = cur.t;
        renderMini(document.getElementById('hold'), hold);
        holdUsed = true;
        if (old) {
            cur = {t: old, m: clone(SHAPES[old]), x: Math.floor(BW / 2) - 1, y: -2};
            if (collides(cur.m, cur.x, cur.y)) gameOver();
        } else spawn();
    }

    function reset() {
        grid = Array.from({length: BH}, () => Array(BW).fill(null));
        bag = [];
        nextT = nextType();
        cur = null;
        hold = null;
        holdUsed = false;
        game.score = 0;
        game.lines = 0;
        game.level = 1;
        game.fallMs = 800;
        game.accum = 0;
        updateHUD();
        updateLevel();
        renderMini(document.getElementById('hold'), null);
        renderMini(document.getElementById('next1'), nextT);
    }

    function updateHUD() {
        document.getElementById('score').textContent = game.score;
        document.getElementById('lines').textContent = game.lines;
        document.getElementById('best').textContent = game.best;
    }

    // ===== Rendering =====
    function draw() {
        // bg
        CTX2.fillStyle = cssVar('--board');
        CTX2.fillRect(0, 0, W, H);
        // grid lines subtle
        CTX2.strokeStyle = cssVar('--grid');
        CTX2.lineWidth = 1;
        CTX2.beginPath();
        for (let x = 0; x <= BW; x++) {
            CTX2.moveTo(x * CELL, 0);
            CTX2.lineTo(x * CELL, BH * CELL);
        }
        for (let y = 0; y <= BH; y++) {
            CTX2.moveTo(0, y * CELL);
            CTX2.lineTo(BW * CELL, y * CELL);
        }
        CTX2.stroke();
        // fixed blocks
        for (let y = 0; y < BH; y++) for (let x = 0; x < BW; x++) {
            const t = grid[y][x];
            if (!t) continue;
            CTX2.fillStyle = cssVar(colorOf(t)) || '#888';
            CTX2.fillRect(x * CELL + 1, y * CELL + 1, CELL - 2, CELL - 2);
        }
        if (cur) {
            // ghost
            let gy = cur.y;
            while (!collides(cur.m, cur.x, gy + 1)) gy++;
            CTX2.fillStyle = cssVar('--ghost');
            drawMatrix(cur.m, cur.x, gy);
            // current piece
            CTX2.fillStyle = cssVar(colorOf(cur.t)) || '#888';
            drawMatrix(cur.m, cur.x, cur.y, true);
        }
    }

    function drawMatrix(m, ox, oy, rounded = false) {
        const h = m.length, w = m[0].length;
        for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
            if (!m[y][x]) continue;
            const px = (ox + x) * CELL, py = (oy + y) * CELL;
            if (rounded) {
                CTX2.fillRect(px + 1, py + 1, CELL - 2, CELL - 2);
            } else {
                CTX2.fillRect(px + 2, py + 2, CELL - 4, CELL - 4);
            }
        }
    }

    function renderMini(c, type) {
        const ctx = c.getContext('2d');
        ctx.clearRect(0, 0, c.width, c.height);
        if (!type) return;
        const m = SHAPES[type];
        const cell = 24;
        const w = m[0].length, h = m.length;
        const ox = Math.floor((c.width - w * cell) / 2), oy = Math.floor((c.height - h * cell) / 2);
        ctx.fillStyle = cssVar(colorOf(type)) || '#888';
        for (let y = 0; y < h; y++) for (let x = 0; x < w; x++) {
            if (m[y][x]) ctx.fillRect(ox + x * cell + 2, oy + y * cell + 2, cell - 4, cell - 4);
        }
    }

    // ===== Loop =====
    let last = 0, rafId;

    function loop(ts) {
        if (!last) last = ts;
        const dt = ts - last;
        last = ts;
        if (game.running && !game.paused && !game.over) {
            // Level zeitbasiert nachführen
            updateLevel();
            game.accum += dt;
            if (game.accum >= game.fallMs) {
                game.accum = 0;
                if (!collides(cur.m, cur.x, cur.y + 1)) cur.y++; else place();
            }
            draw();
        }
        rafId = requestAnimationFrame(loop);
    }

    // ===== Start / Over =====
    function start() {
        reset();
        spawn();
        game.running = true;
        game.over = false;
        game.startedAt = new Date();
        document.body.classList.add('playing');
        document.getElementById('startLayer').classList.add('hidden');
        document.getElementById('gameOverLayer').classList.add('hidden');
        cancelAnimationFrame(rafId);
        last = 0;
        rafId = requestAnimationFrame(loop);
    }

    function gameOver() {
        if (game.over) return;
        game.over = true;
        game.running = false;
        document.body.classList.remove('playing');
        game.endedAt = new Date();
        if (game.score > game.best) {
            game.best = game.score;
            localStorage.setItem(LS_KEY, String(game.best));
        }
        updateHUD();
        showSummaryAndSubmit();
    }

    // ===== Controls =====
    const keymap = {
        ArrowLeft: 'L',
        ArrowRight: 'R',
        ArrowDown: 'D',
        ArrowUp: 'ROT',
        Space: 'HARD',
        KeyA: 'L',
        KeyD: 'R',
        KeyS: 'D',
        KeyW: 'ROT',
        KeyX: 'ROT',
        KeyZ: 'ROT_CCW',
        KeyC: 'HOLD',
        ShiftLeft: 'HOLD',
        KeyP: 'PAUSE'
    };

    function handleGameKeys(e) {
        const act = keymap[e.code];
        if (!act) return false;
        e.preventDefault();
        if (!game.running) return false;
        switch (act) {
            case 'L':
                move(-1);
                break;
            case 'R':
                move(1);
                break;
            case 'D':
                softDrop();
                break;
            case 'ROT':
                rotateCur();
                break;
            case 'ROT_CCW':
                rotateCur();
                rotateCur();
                rotateCur();
                break;
            case 'HARD':
                hardDrop();
                break;
            case 'HOLD':
                holdSwap();
                break;
            case 'PAUSE':
                game.paused = !game.paused;
                break;
        }
        draw();
        return true;
    }

    document.addEventListener('keydown', (e) => {
        if (handleGameKeys(e)) return;
        // allow Enter/Space to start when not running
        const startLayer = document.getElementById('startLayer');
        if (!game.running && !startLayer.classList.contains('hidden')) {
            if (e.code === 'Enter' || e.code === 'Space') {
                e.preventDefault();
                start();
            }
        }
    });

    // Touch: swipe left/right/down, tap=rotate, longtap=hard drop
    let t0 = null, longTimer = null;
    CAN.addEventListener('touchstart', e => {
        if (!game.running) return;
        const t = e.touches[0];
        t0 = {x: t.clientX, y: t.clientY, time: performance.now()};
        longTimer = setTimeout(() => {
            hardDrop();
            draw();
        }, 450);
        e.preventDefault();
    }, {passive: false});
    CAN.addEventListener('touchmove', e => {
        if (!game.running || !t0) return;
        const t = e.touches[0];
        const dx = t.clientX - t0.x, dy = t.clientY - t0.y;
        if (Math.abs(dx) > 24 || Math.abs(dy) > 24) {
            clearTimeout(longTimer);
            if (Math.abs(dx) > Math.abs(dy)) {
                move(dx > 0 ? 1 : -1);
                t0.x = t.clientX;
            } else {
                softDrop();
                t0.y = t.clientY;
            }
            draw();
        }
        e.preventDefault();
    }, {passive: false});
    CAN.addEventListener('touchend', e => {
        if (!t0) return;
        const dt = performance.now() - t0.time;
        clearTimeout(longTimer);
        if (dt < 250) {
            rotateCur();
            draw();
        }
        t0 = null;
        e.preventDefault();
    }, {passive: false});

    // Buttons
    const startBtn = document.getElementById('startBtn');
    const againBtn = document.getElementById('againBtn');

    function safeStart(ev) {
        ev?.preventDefault?.();
        ev?.stopPropagation?.();
        if (game.running) return;
        start();
    }

    startBtn.setAttribute('type', 'button');
    startBtn.style.touchAction = 'manipulation';
    startBtn.addEventListener('click', safeStart);
    startBtn.addEventListener('pointerdown', safeStart, {passive: false});
    startBtn.addEventListener('touchend', safeStart, {passive: false});
    // Start by tapping/clicking anywhere on the start layer
    const startLayer = document.getElementById('startLayer');
    startLayer.addEventListener('pointerdown', (e) => {
        if (e.target.id !== "startBtn") {
            e.preventDefault();
            safeStart(e);
        }
    }, {passive: false});
    againBtn.addEventListener('click', (e) => {
        e.preventDefault();
        start();
    });

    // Pause visibility
    document.addEventListener('visibilitychange', () => {
        if (document.hidden && CFG.requireVisibility) {
            game.paused = true;
        } else if (game.running) {
            game.paused = false;
        }
    });

    // ===== Submit Result =====
    async function postResult(url, token, payload) {
        if (!url) return {status: 'ok', local: true};
        const res = await fetch(url, {
            method: 'POST',
            headers: {'Content-Type': 'application/json', ...(token ? {Authorization: `Bearer ${token}`} : {})},
            body: JSON.stringify(payload),
            keepalive: true
        });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        return res.json().catch(() => ({status: 'ok'}));
    }

    const sleep = ms => new Promise(r => setTimeout(r, ms));

    async function showSummaryAndSubmit() {
        cancelAnimationFrame(rafId);
        const layer = document.getElementById('gameOverLayer');
        const s = document.getElementById('summary');
        s.innerHTML = `Score: <b>${game.score}</b><br>Lines: ${game.lines}<br>Level: ${game.level}`;
        const submitState = document.getElementById('submitState');
        const errBox = document.getElementById('errBox');
        errBox.classList.add('hidden');
        errBox.textContent = '';
        layer.classList.remove('hidden');
        const payload = {
            partyId: CTX.partyId,
            playerId: CTX.playerId,
            gameId: CTX.gameId,
            sessionId: CTX.sessionId,
            score: game.score,
            maxScore: 999999,
            completed: true,
            durationMs: game.endedAt - game.startedAt,
            startedAt: game.startedAt.toISOString(),
            endedAt: game.endedAt.toISOString(),
            attempt: 1,
            metadata: {lines: game.lines, level: game.level},
            clientInfo: {userAgent: navigator.userAgent, viewport: {w: innerWidth, h: innerHeight}}
        };
        if (isFileOrigin && !CFG.callbackUrl) {
            submitState.textContent = 'Lokaler Testmodus – kein Submit';
            return;
        }
        let ok = false, lastErr = null;
        const {attempts, baseMs} = CFG.backoff;
        let i = 0;
        while (i < attempts) {
            try {
                submitState.textContent = i ? `Sende… Versuch ${i + 1}/${attempts}` : 'Sende Ergebnis…';
                const res = await postResult(CFG.callbackUrl, CFG.token, payload);
                submitState.textContent = 'Ergebnis gespeichert.';
                ok = true;
                if (res && res.scoreboardUrl) {
                    const btn = document.getElementById('scoreboardBtn');
                    btn.hidden = false;
                    btn.onclick = () => open(res.scoreboardUrl, '_blank');
                }
                break;
            } catch (e) {
                lastErr = e;
                i++;
                if (i < attempts) await sleep(baseMs * (2 ** i));
            }
        }
        if (!ok) {
            submitState.textContent = 'Speichern fehlgeschlagen.';
            errBox.textContent = lastErr?.message || 'Unbekannter Fehler';
            errBox.classList.remove('hidden');
        }
    }

    // ===== Init =====
    (function init() {
        document.getElementById('ctx').textContent = [`party:${CTX.partyId?.slice(0, 8) || '—'}`, `player:${CTX.playerId?.slice(0, 8) || '—'}`, `game:${CTX.gameId}`].join(' • ');
        reset();
        draw();
        document.getElementById('startLayer').classList.remove('hidden');
    })();
</script>
</body>
</html>
